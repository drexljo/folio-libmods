#!/bin/bash

# call_tower
# Takes care of signing on and off with okapi, as well as registering the port
# to a dynamic file to avoid module collisions.
# Requires either 'signon' or 'signoff' as parameters

# The following environment variables have to be set:
# HOST (optional, for systems behind NATs)
# JSON_FILE
# OKAPI_HOST
# OKAPI_PORT
# PORT


# ================================= Copyright =================================
# Version 0.0.1 (2020-06-29), Copyright (C) 2020
# Author: Jo Drexl (johannes.drexl@lrz.de) for FOLIO
# Coauthors: -

#   This file is part of the LRZ FOLIO debian package

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#    http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#   On Debian systems, the full text of the Apache License version 2.0
#   can be found in the file 
#     `/usr/share/common-licenses/Apache-2.0'


# ================================= Variables =================================

# Registry file for modules and their used ports
CT_REGFILE="/tmp/folio_registry"


# ================================= Functions =================================

# Delete module port entry in registry file
ct_call() {
  # Expects the action as parameter 1
  # Returns 0 on success
  # Returns 1 on failure
  
  # Local variables
  local ACTION="$1"
  local ERRORS
  local RETURN
  
  # Check action
  case "$ACTION" in
    bye)
      # Delete module for tenants 
      # Delete module instance from Okapi
      if RETURN=$(curl -X DELETE -D - -w '\n' http://$OKAPI_HOST:$OKAPI_PORT/_/discovery/modules/$CT_MODULE_ID/$HOST-$PORT)
        then
          # Interpret return message
          if echo -e "$RETURN" | grep "HTTP/1.1 204 No Content" > /dev/null 2>&1
            then
              echo "INFO: Module deregistered from Okapi."
              return 0
            else
              echo -e "WARN: Okapi answered with unknown message:\n$RETURN"
              return 1
          fi
        else
          echo "FATAL: Could not deregister from Okapi!"
          return 1
      fi
      ;;
    hello)
      ;;
    *)
      echo "FATAL: Unknown action in subroutine ct_call."
      return 1
      ;;
  esac
}

# Create JSON to say hello
ct_jsonhello() {
  # Returns 0 on success
  # Returns 1 on failure
  
  cat > "$CT_TMPJSON_HELLO" <<END
{
  "url": "http://$HOST:$PORT",
  "srvcId": "$CT_MODULE_ID"
}
END

# Check if that worked out
  if [ "$?" = "0" ]
    then
      return 0
    else
      return 1
  fi
}

# Create JSON for registering modules to tenants
ct_jsontenant() {
  # Returns 0 on success
  # Returns 1 on failure
  
  cat > "$CT_TMPJSON_TENANTS" <<END
{
  "id": "$CT_MODULE_ID"
}
END

# Check if that worked out
  if [ "$?" = "0" ]
    then
      return 0
    else
      return 1
  fi
}

# Delete module port entry in registry file
ct_portdereg() {
  # Returns 0 on success
  # Returns 1 on failure
  
  # Delete the line which is expected to be there
  sed -i "/^$CT_MODULE_ID $PORT$/d" "$CT_REGFILE"
  # Check if the line is not there
  if grep -E "^$CT_MODULE_ID $PORT$" "$CT_REGFILE" > /dev/null 2>&1
    then
      # If deregistration does not work, the admin definitely has to know
      echo "FATAL: Could not deregister '$CT_MODULE_ID' port '$PORT' from the registry file '$CT_REGFILE'!"
      return 1
  fi
  # If we arrive here, all is good now
  return 0
}

# Register module and the port to file 
ct_portreg() {
  # Returns 0 on success
  # Returns 1 on failure
  
  # Local variables
  local CULPRIT
  
  # Registering the port
  if ! echo "$CT_MODULE_ID $PORT" >> "$CT_REGFILE"
    then
      # If deregistration does not work, the admin definitely has to know
      echo "FATAL: Could not register '$CT_MODULE_ID' port '$PORT' to the registry file '$CT_REGFILE'!"
      return 1
  fi
  # Wait for a bit to counter race conditions
  sleep 0.$RANDOM
  # Conduct the check
  if [ $(grep -cE ".* $PORT$" "$CT_REGFILE") != "1" ]
    then
      # Someone else has registered this port, find out the culprit and tell 
      # the admin
      CULPRIT=$(grep -E ".* $PORT$" "$CT_REGFILE" | grep -vE "^$CT_MODULE_ID $PORT$" | cut -d " " -f 1 | head -n 1)
      echo "FATAL: $CULPRIT has just registered port '$PORT' configured for this service!"
      # Try to undo our own registration, for this means the java process will
      # not be able to start properly
      ct_portdereg
      # Return in shame
      return 1
  fi
  # Everything went as it should
  return 0
}

# Checks if the port has already been claimed
ct_portcheck() {
  # Returns 0 on port unused
  # Returns 1 on failure or port already in use
  
  # Local variables
  local CULPRIT
  
  # Check if the port is already registered
  if ! grep -E ".* $PORT$" "$CT_REGFILE" > /dev/null 2>&1
    then
      # Port not registered, we're done
      return 0
  fi
  # The registered port could be a not deleted artifact from a previous run, 
  # check that
  if grep -E "^$CT_MODULE_ID $PORT$" "$CT_REGFILE" > /dev/null 2>&1
    then
      # If deregistration does not work, the admin definitely has to know
      echo "WARN: '$CT_MODULE_ID' port '$PORT' was already registered, removing registration..."
      if ct_portdereg
        then
          # Deregistration was successful, clear environment
          return 0
        else
          # Deregistration failed, return failure
          return 1
      fi
  fi
  # Obviously this port is used by another service
  CULPRIT=$(grep -E ".* $PORT$" "$CT_REGFILE" | grep -E "^$CT_MODULE_ID $PORT$" | cut -d " " -f 1)
  echo "FATAL: Port '$PORT' in use by '$CULPRIT'!"
  return 1  
}




# =============================== Prerequisites ===============================

# Fetch parameter
if [ "$1" = "signoff" -o "$1" = "signon" ]
  then
    CT_ACTION="$1"
  else
    echo "FATAL: Unrecognized action!"
    exit 1
fi

# Check for variables to be set
if [ "$HOST" = "" ]
  then
    HOST=$(hostname --fqdn)
fi
if [ "$JSON_FILE" = "" ]
  then
    echo "FATAL: No JSON file specified!"
    exit 1
fi
if [ "$OKAPI_HOST" = "" ]
  then
    echo "FATAL: No OKAPI_HOST specified!"
    exit 1
fi
if [ "$OKAPI_PORT" = "" ]
  then
    echo "FATAL: No OKAPI_PORT specified!"
    exit 1
fi
if [ "$PORT" = "" ]
  then
    echo "FATAL: No PORT specified!"
    exit 1
fi

# Check for the JSON file
if [ ! -f "$JSON_FILE" ]
  then
    echo "FATAL: JSON file missing!"
    exit 1
fi

# Read the module id
CT_MODULE_ID=$(grep -Em 1 "\"id\":" "$JSON_FILE" | cut -d '"' -f 4 -s)
# Check if it's invalid
if ! echo "$CT_MODULE_ID" | grep -E "^[-a-z]+[\.0-9]+$" > /dev/null
  then
    echo "FATAL: Detected module ID was '$CT_MODULE_ID', can't work with that!"
    exit 1
fi
# Get module name
CT_MODULE=$(echo "$CT_MODULE_ID" | grep -oE "[-a-z]+[a-z]")
# Get interface name
CT_INTERFACE=$(grep -Em 1 -A 3 "\"provides\":" "$JSON_FILE" | grep -Em 1 "\"id\":" | cut -d '"' -f 4 -s)
# Check if it's invalid
if ! echo "$CT_INTERFACE" | grep -E "^[-a-z]+[\.0-9]+$" > /dev/null
  then
    echo "FATAL: Detected interface was '$CT_INTERFACE', can't work with that!"
    exit 1
fi

# Set temp files for communication
CT_TMPJSON_HELLO="/tmp/$CT_MODULE-$PORT-hello.json"
CT_TMPJSON_TENANTS="/tmp/$CT_MODULE-$PORT-tenants.json"


# =================================== Main ====================================

# Work through actions to be done
case "$CT_ACTION" in
  signoff)
    # Call okapi to disable module
    ct_call bye
    if [ "$?" != "0" ]
      then
        # Messaging has already been taken care of
        exit 1
    fi
    # Check and register port
    ct_portdereg
    if [ "$?" != "0" ]
      then
        # Messaging has already been taken care of
        exit 1
    fi
    ;;
  signon)
    # Check and register port
    ct_portcheck && ct_portreg
    if [ "$?" != "0" ]
      then
        # Messaging has already been taken care of
        exit 1
    fi
    # Call okapi to enable module
    ct_call hello
    if [ "$?" != "0" ]
      then
        # Messaging has already been taken care of
        exit 1
    fi
    ;;
  *)
    # Should not happen
    echo "FATAL: Unrecognized action!"
    ;;
esac

exit 0



# Check and register port
ct_portcheck && ct_portreg
if [ "$?" != "0" ]
  then
    # Messaging has already been taken care of
    exit 1
fi

# Prepare JSON
if ct_jsonprep
# 
if ! curl -w '\n' -X POST -D - -H "Content-type: application/json" \
        -d @"$JSON_REG" http://$OKAPI_HOST:$OKAPI_PORT/_/proxy/modules >> $LOG
  then
    exit 1
fi

exit 0
